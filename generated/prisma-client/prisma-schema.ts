// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregatePayment {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  tok: PaymentStatus!
  tnumber: Int
  mname: String
  mid: String
  spay: Int!
  trno: String
  reg_date: DateTime!
  pay_dtm: DateTime!
  content: String
  bpay: Int!
  qpay: Int!
  brefund: Int!
  qrefund: Int!
  accea: Int!
  qaccea: Int!
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime!
  qendday: DateTime!
  msg2: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  tok: PaymentStatus
  tnumber: Int
  mname: String
  mid: String
  spay: Int
  trno: String
  reg_date: DateTime
  pay_dtm: DateTime
  content: String
  bpay: Int
  qpay: Int
  brefund: Int
  qrefund: Int
  accea: Int
  qaccea: Int
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime
  qendday: DateTime
  msg2: String
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  tok_ASC
  tok_DESC
  tnumber_ASC
  tnumber_DESC
  mname_ASC
  mname_DESC
  mid_ASC
  mid_DESC
  spay_ASC
  spay_DESC
  trno_ASC
  trno_DESC
  reg_date_ASC
  reg_date_DESC
  pay_dtm_ASC
  pay_dtm_DESC
  content_ASC
  content_DESC
  bpay_ASC
  bpay_DESC
  qpay_ASC
  qpay_DESC
  brefund_ASC
  brefund_DESC
  qrefund_ASC
  qrefund_DESC
  accea_ASC
  accea_DESC
  qaccea_ASC
  qaccea_DESC
  req_day_ASC
  req_day_DESC
  req_qday_ASC
  req_qday_DESC
  endday_ASC
  endday_DESC
  qendday_ASC
  qendday_DESC
  msg2_ASC
  msg2_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  tok: PaymentStatus!
  tnumber: Int
  mname: String
  mid: String
  spay: Int!
  trno: String
  reg_date: DateTime!
  pay_dtm: DateTime!
  content: String
  bpay: Int!
  qpay: Int!
  brefund: Int!
  qrefund: Int!
  accea: Int!
  qaccea: Int!
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime!
  qendday: DateTime!
  msg2: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PaymentStatus {
  WAIT
  ACCEPTED
  CANCELED
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  tok: PaymentStatus
  tnumber: Int
  mname: String
  mid: String
  spay: Int
  trno: String
  reg_date: DateTime
  pay_dtm: DateTime
  content: String
  bpay: Int
  qpay: Int
  brefund: Int
  qrefund: Int
  accea: Int
  qaccea: Int
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime
  qendday: DateTime
  msg2: String
}

input PaymentUpdateManyMutationInput {
  tok: PaymentStatus
  tnumber: Int
  mname: String
  mid: String
  spay: Int
  trno: String
  reg_date: DateTime
  pay_dtm: DateTime
  content: String
  bpay: Int
  qpay: Int
  brefund: Int
  qrefund: Int
  accea: Int
  qaccea: Int
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime
  qendday: DateTime
  msg2: String
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tok: PaymentStatus
  tok_not: PaymentStatus
  tok_in: [PaymentStatus!]
  tok_not_in: [PaymentStatus!]
  tnumber: Int
  tnumber_not: Int
  tnumber_in: [Int!]
  tnumber_not_in: [Int!]
  tnumber_lt: Int
  tnumber_lte: Int
  tnumber_gt: Int
  tnumber_gte: Int
  mname: String
  mname_not: String
  mname_in: [String!]
  mname_not_in: [String!]
  mname_lt: String
  mname_lte: String
  mname_gt: String
  mname_gte: String
  mname_contains: String
  mname_not_contains: String
  mname_starts_with: String
  mname_not_starts_with: String
  mname_ends_with: String
  mname_not_ends_with: String
  mid: String
  mid_not: String
  mid_in: [String!]
  mid_not_in: [String!]
  mid_lt: String
  mid_lte: String
  mid_gt: String
  mid_gte: String
  mid_contains: String
  mid_not_contains: String
  mid_starts_with: String
  mid_not_starts_with: String
  mid_ends_with: String
  mid_not_ends_with: String
  spay: Int
  spay_not: Int
  spay_in: [Int!]
  spay_not_in: [Int!]
  spay_lt: Int
  spay_lte: Int
  spay_gt: Int
  spay_gte: Int
  trno: String
  trno_not: String
  trno_in: [String!]
  trno_not_in: [String!]
  trno_lt: String
  trno_lte: String
  trno_gt: String
  trno_gte: String
  trno_contains: String
  trno_not_contains: String
  trno_starts_with: String
  trno_not_starts_with: String
  trno_ends_with: String
  trno_not_ends_with: String
  reg_date: DateTime
  reg_date_not: DateTime
  reg_date_in: [DateTime!]
  reg_date_not_in: [DateTime!]
  reg_date_lt: DateTime
  reg_date_lte: DateTime
  reg_date_gt: DateTime
  reg_date_gte: DateTime
  pay_dtm: DateTime
  pay_dtm_not: DateTime
  pay_dtm_in: [DateTime!]
  pay_dtm_not_in: [DateTime!]
  pay_dtm_lt: DateTime
  pay_dtm_lte: DateTime
  pay_dtm_gt: DateTime
  pay_dtm_gte: DateTime
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  bpay: Int
  bpay_not: Int
  bpay_in: [Int!]
  bpay_not_in: [Int!]
  bpay_lt: Int
  bpay_lte: Int
  bpay_gt: Int
  bpay_gte: Int
  qpay: Int
  qpay_not: Int
  qpay_in: [Int!]
  qpay_not_in: [Int!]
  qpay_lt: Int
  qpay_lte: Int
  qpay_gt: Int
  qpay_gte: Int
  brefund: Int
  brefund_not: Int
  brefund_in: [Int!]
  brefund_not_in: [Int!]
  brefund_lt: Int
  brefund_lte: Int
  brefund_gt: Int
  brefund_gte: Int
  qrefund: Int
  qrefund_not: Int
  qrefund_in: [Int!]
  qrefund_not_in: [Int!]
  qrefund_lt: Int
  qrefund_lte: Int
  qrefund_gt: Int
  qrefund_gte: Int
  accea: Int
  accea_not: Int
  accea_in: [Int!]
  accea_not_in: [Int!]
  accea_lt: Int
  accea_lte: Int
  accea_gt: Int
  accea_gte: Int
  qaccea: Int
  qaccea_not: Int
  qaccea_in: [Int!]
  qaccea_not_in: [Int!]
  qaccea_lt: Int
  qaccea_lte: Int
  qaccea_gt: Int
  qaccea_gte: Int
  req_day: DateTime
  req_day_not: DateTime
  req_day_in: [DateTime!]
  req_day_not_in: [DateTime!]
  req_day_lt: DateTime
  req_day_lte: DateTime
  req_day_gt: DateTime
  req_day_gte: DateTime
  req_qday: DateTime
  req_qday_not: DateTime
  req_qday_in: [DateTime!]
  req_qday_not_in: [DateTime!]
  req_qday_lt: DateTime
  req_qday_lte: DateTime
  req_qday_gt: DateTime
  req_qday_gte: DateTime
  endday: DateTime
  endday_not: DateTime
  endday_in: [DateTime!]
  endday_not_in: [DateTime!]
  endday_lt: DateTime
  endday_lte: DateTime
  endday_gt: DateTime
  endday_gte: DateTime
  qendday: DateTime
  qendday_not: DateTime
  qendday_in: [DateTime!]
  qendday_not_in: [DateTime!]
  qendday_lt: DateTime
  qendday_lte: DateTime
  qendday_gt: DateTime
  qendday_gte: DateTime
  msg2: String
  msg2_not: String
  msg2_in: [String!]
  msg2_not_in: [String!]
  msg2_lt: String
  msg2_lte: String
  msg2_gt: String
  msg2_gte: String
  msg2_contains: String
  msg2_not_contains: String
  msg2_starts_with: String
  msg2_not_starts_with: String
  msg2_ends_with: String
  msg2_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  birthday: Int!
  position: String!
  startWorkedAt: DateTime!
  endWorkedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  birthday: Int!
  position: String!
  startWorkedAt: DateTime!
  endWorkedAt: DateTime
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  birthday_ASC
  birthday_DESC
  position_ASC
  position_DESC
  startWorkedAt_ASC
  startWorkedAt_DESC
  endWorkedAt_ASC
  endWorkedAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  birthday: Int!
  position: String!
  startWorkedAt: DateTime!
  endWorkedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  birthday: Int
  position: String
  startWorkedAt: DateTime
  endWorkedAt: DateTime
}

input UserUpdateManyMutationInput {
  name: String
  birthday: Int
  position: String
  startWorkedAt: DateTime
  endWorkedAt: DateTime
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  birthday: Int
  birthday_not: Int
  birthday_in: [Int!]
  birthday_not_in: [Int!]
  birthday_lt: Int
  birthday_lte: Int
  birthday_gt: Int
  birthday_gte: Int
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  startWorkedAt: DateTime
  startWorkedAt_not: DateTime
  startWorkedAt_in: [DateTime!]
  startWorkedAt_not_in: [DateTime!]
  startWorkedAt_lt: DateTime
  startWorkedAt_lte: DateTime
  startWorkedAt_gt: DateTime
  startWorkedAt_gte: DateTime
  endWorkedAt: DateTime
  endWorkedAt_not: DateTime
  endWorkedAt_in: [DateTime!]
  endWorkedAt_not_in: [DateTime!]
  endWorkedAt_lt: DateTime
  endWorkedAt_lte: DateTime
  endWorkedAt_gt: DateTime
  endWorkedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`