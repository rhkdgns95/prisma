// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateEmployee {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Employee {
  id: ID!
  name: String!
  birthday: DateTime!
  position: Int!
  startWorkedAt: DateTime!
  endWorkedAt: DateTime
  normalPay: Int!
  positionPay: Int!
  publish: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EmployeeConnection {
  pageInfo: PageInfo!
  edges: [EmployeeEdge]!
  aggregate: AggregateEmployee!
}

input EmployeeCreateInput {
  id: ID
  name: String!
  birthday: DateTime!
  position: Int!
  startWorkedAt: DateTime!
  endWorkedAt: DateTime
  normalPay: Int!
  positionPay: Int!
  publish: Int!
}

type EmployeeEdge {
  node: Employee!
  cursor: String!
}

enum EmployeeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  birthday_ASC
  birthday_DESC
  position_ASC
  position_DESC
  startWorkedAt_ASC
  startWorkedAt_DESC
  endWorkedAt_ASC
  endWorkedAt_DESC
  normalPay_ASC
  normalPay_DESC
  positionPay_ASC
  positionPay_DESC
  publish_ASC
  publish_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmployeePreviousValues {
  id: ID!
  name: String!
  birthday: DateTime!
  position: Int!
  startWorkedAt: DateTime!
  endWorkedAt: DateTime
  normalPay: Int!
  positionPay: Int!
  publish: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EmployeeSubscriptionPayload {
  mutation: MutationType!
  node: Employee
  updatedFields: [String!]
  previousValues: EmployeePreviousValues
}

input EmployeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeWhereInput
  AND: [EmployeeSubscriptionWhereInput!]
  OR: [EmployeeSubscriptionWhereInput!]
  NOT: [EmployeeSubscriptionWhereInput!]
}

input EmployeeUpdateInput {
  name: String
  birthday: DateTime
  position: Int
  startWorkedAt: DateTime
  endWorkedAt: DateTime
  normalPay: Int
  positionPay: Int
  publish: Int
}

input EmployeeUpdateManyMutationInput {
  name: String
  birthday: DateTime
  position: Int
  startWorkedAt: DateTime
  endWorkedAt: DateTime
  normalPay: Int
  positionPay: Int
  publish: Int
}

input EmployeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  birthday: DateTime
  birthday_not: DateTime
  birthday_in: [DateTime!]
  birthday_not_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  position: Int
  position_not: Int
  position_in: [Int!]
  position_not_in: [Int!]
  position_lt: Int
  position_lte: Int
  position_gt: Int
  position_gte: Int
  startWorkedAt: DateTime
  startWorkedAt_not: DateTime
  startWorkedAt_in: [DateTime!]
  startWorkedAt_not_in: [DateTime!]
  startWorkedAt_lt: DateTime
  startWorkedAt_lte: DateTime
  startWorkedAt_gt: DateTime
  startWorkedAt_gte: DateTime
  endWorkedAt: DateTime
  endWorkedAt_not: DateTime
  endWorkedAt_in: [DateTime!]
  endWorkedAt_not_in: [DateTime!]
  endWorkedAt_lt: DateTime
  endWorkedAt_lte: DateTime
  endWorkedAt_gt: DateTime
  endWorkedAt_gte: DateTime
  normalPay: Int
  normalPay_not: Int
  normalPay_in: [Int!]
  normalPay_not_in: [Int!]
  normalPay_lt: Int
  normalPay_lte: Int
  normalPay_gt: Int
  normalPay_gte: Int
  positionPay: Int
  positionPay_not: Int
  positionPay_in: [Int!]
  positionPay_not_in: [Int!]
  positionPay_lt: Int
  positionPay_lte: Int
  positionPay_gt: Int
  positionPay_gte: Int
  publish: Int
  publish_not: Int
  publish_in: [Int!]
  publish_not_in: [Int!]
  publish_lt: Int
  publish_lte: Int
  publish_gt: Int
  publish_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createEmployee(data: EmployeeCreateInput!): Employee!
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateManyEmployees(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  upsertEmployee(where: EmployeeWhereUniqueInput!, create: EmployeeCreateInput!, update: EmployeeUpdateInput!): Employee!
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  tok: PaymentStatus!
  tnumber: Int
  mname: String
  mid: String
  spay: Int!
  trno: String
  reg_date: DateTime!
  pay_dtm: DateTime!
  content: String
  bpay: Int!
  qpay: Int!
  brefund: Int!
  qrefund: Int!
  accea: Int!
  qaccea: Int!
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime!
  qendday: DateTime!
  msg2: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  tok: PaymentStatus
  tnumber: Int
  mname: String
  mid: String
  spay: Int
  trno: String
  reg_date: DateTime
  pay_dtm: DateTime
  content: String
  bpay: Int
  qpay: Int
  brefund: Int
  qrefund: Int
  accea: Int
  qaccea: Int
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime
  qendday: DateTime
  msg2: String
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  tok_ASC
  tok_DESC
  tnumber_ASC
  tnumber_DESC
  mname_ASC
  mname_DESC
  mid_ASC
  mid_DESC
  spay_ASC
  spay_DESC
  trno_ASC
  trno_DESC
  reg_date_ASC
  reg_date_DESC
  pay_dtm_ASC
  pay_dtm_DESC
  content_ASC
  content_DESC
  bpay_ASC
  bpay_DESC
  qpay_ASC
  qpay_DESC
  brefund_ASC
  brefund_DESC
  qrefund_ASC
  qrefund_DESC
  accea_ASC
  accea_DESC
  qaccea_ASC
  qaccea_DESC
  req_day_ASC
  req_day_DESC
  req_qday_ASC
  req_qday_DESC
  endday_ASC
  endday_DESC
  qendday_ASC
  qendday_DESC
  msg2_ASC
  msg2_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  tok: PaymentStatus!
  tnumber: Int
  mname: String
  mid: String
  spay: Int!
  trno: String
  reg_date: DateTime!
  pay_dtm: DateTime!
  content: String
  bpay: Int!
  qpay: Int!
  brefund: Int!
  qrefund: Int!
  accea: Int!
  qaccea: Int!
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime!
  qendday: DateTime!
  msg2: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PaymentStatus {
  WAIT
  ACCEPTED
  CANCELED
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  tok: PaymentStatus
  tnumber: Int
  mname: String
  mid: String
  spay: Int
  trno: String
  reg_date: DateTime
  pay_dtm: DateTime
  content: String
  bpay: Int
  qpay: Int
  brefund: Int
  qrefund: Int
  accea: Int
  qaccea: Int
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime
  qendday: DateTime
  msg2: String
}

input PaymentUpdateManyMutationInput {
  tok: PaymentStatus
  tnumber: Int
  mname: String
  mid: String
  spay: Int
  trno: String
  reg_date: DateTime
  pay_dtm: DateTime
  content: String
  bpay: Int
  qpay: Int
  brefund: Int
  qrefund: Int
  accea: Int
  qaccea: Int
  req_day: DateTime
  req_qday: DateTime
  endday: DateTime
  qendday: DateTime
  msg2: String
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tok: PaymentStatus
  tok_not: PaymentStatus
  tok_in: [PaymentStatus!]
  tok_not_in: [PaymentStatus!]
  tnumber: Int
  tnumber_not: Int
  tnumber_in: [Int!]
  tnumber_not_in: [Int!]
  tnumber_lt: Int
  tnumber_lte: Int
  tnumber_gt: Int
  tnumber_gte: Int
  mname: String
  mname_not: String
  mname_in: [String!]
  mname_not_in: [String!]
  mname_lt: String
  mname_lte: String
  mname_gt: String
  mname_gte: String
  mname_contains: String
  mname_not_contains: String
  mname_starts_with: String
  mname_not_starts_with: String
  mname_ends_with: String
  mname_not_ends_with: String
  mid: String
  mid_not: String
  mid_in: [String!]
  mid_not_in: [String!]
  mid_lt: String
  mid_lte: String
  mid_gt: String
  mid_gte: String
  mid_contains: String
  mid_not_contains: String
  mid_starts_with: String
  mid_not_starts_with: String
  mid_ends_with: String
  mid_not_ends_with: String
  spay: Int
  spay_not: Int
  spay_in: [Int!]
  spay_not_in: [Int!]
  spay_lt: Int
  spay_lte: Int
  spay_gt: Int
  spay_gte: Int
  trno: String
  trno_not: String
  trno_in: [String!]
  trno_not_in: [String!]
  trno_lt: String
  trno_lte: String
  trno_gt: String
  trno_gte: String
  trno_contains: String
  trno_not_contains: String
  trno_starts_with: String
  trno_not_starts_with: String
  trno_ends_with: String
  trno_not_ends_with: String
  reg_date: DateTime
  reg_date_not: DateTime
  reg_date_in: [DateTime!]
  reg_date_not_in: [DateTime!]
  reg_date_lt: DateTime
  reg_date_lte: DateTime
  reg_date_gt: DateTime
  reg_date_gte: DateTime
  pay_dtm: DateTime
  pay_dtm_not: DateTime
  pay_dtm_in: [DateTime!]
  pay_dtm_not_in: [DateTime!]
  pay_dtm_lt: DateTime
  pay_dtm_lte: DateTime
  pay_dtm_gt: DateTime
  pay_dtm_gte: DateTime
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  bpay: Int
  bpay_not: Int
  bpay_in: [Int!]
  bpay_not_in: [Int!]
  bpay_lt: Int
  bpay_lte: Int
  bpay_gt: Int
  bpay_gte: Int
  qpay: Int
  qpay_not: Int
  qpay_in: [Int!]
  qpay_not_in: [Int!]
  qpay_lt: Int
  qpay_lte: Int
  qpay_gt: Int
  qpay_gte: Int
  brefund: Int
  brefund_not: Int
  brefund_in: [Int!]
  brefund_not_in: [Int!]
  brefund_lt: Int
  brefund_lte: Int
  brefund_gt: Int
  brefund_gte: Int
  qrefund: Int
  qrefund_not: Int
  qrefund_in: [Int!]
  qrefund_not_in: [Int!]
  qrefund_lt: Int
  qrefund_lte: Int
  qrefund_gt: Int
  qrefund_gte: Int
  accea: Int
  accea_not: Int
  accea_in: [Int!]
  accea_not_in: [Int!]
  accea_lt: Int
  accea_lte: Int
  accea_gt: Int
  accea_gte: Int
  qaccea: Int
  qaccea_not: Int
  qaccea_in: [Int!]
  qaccea_not_in: [Int!]
  qaccea_lt: Int
  qaccea_lte: Int
  qaccea_gt: Int
  qaccea_gte: Int
  req_day: DateTime
  req_day_not: DateTime
  req_day_in: [DateTime!]
  req_day_not_in: [DateTime!]
  req_day_lt: DateTime
  req_day_lte: DateTime
  req_day_gt: DateTime
  req_day_gte: DateTime
  req_qday: DateTime
  req_qday_not: DateTime
  req_qday_in: [DateTime!]
  req_qday_not_in: [DateTime!]
  req_qday_lt: DateTime
  req_qday_lte: DateTime
  req_qday_gt: DateTime
  req_qday_gte: DateTime
  endday: DateTime
  endday_not: DateTime
  endday_in: [DateTime!]
  endday_not_in: [DateTime!]
  endday_lt: DateTime
  endday_lte: DateTime
  endday_gt: DateTime
  endday_gte: DateTime
  qendday: DateTime
  qendday_not: DateTime
  qendday_in: [DateTime!]
  qendday_not_in: [DateTime!]
  qendday_lt: DateTime
  qendday_lte: DateTime
  qendday_gt: DateTime
  qendday_gte: DateTime
  msg2: String
  msg2_not: String
  msg2_in: [String!]
  msg2_not_in: [String!]
  msg2_lt: String
  msg2_lte: String
  msg2_gt: String
  msg2_gte: String
  msg2_contains: String
  msg2_not_contains: String
  msg2_starts_with: String
  msg2_not_starts_with: String
  msg2_ends_with: String
  msg2_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee]!
  employeesConnection(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  node(id: ID!): Node
}

type Subscription {
  employee(where: EmployeeSubscriptionWhereInput): EmployeeSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
}
`